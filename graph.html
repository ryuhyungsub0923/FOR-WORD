diff --git a/graph.html b/graph.html
index 18889bcac7f3621130103a94f0c870004ade6f1b..2f707c718f35baff04b4e3cd33638854c2af36ae 100644
--- a/graph.html
+++ b/graph.html
@@ -352,96 +352,96 @@
       line-height:1.4;
       color:#fff;
       letter-spacing:-0.02em;
     }
     .graph-meta{
       font-size:12px;
       line-height:1.2;
       color:rgba(255,255,255,0.6);
       letter-spacing:-0.02em;
     }
     .graph-controls{
       display:flex;
       gap:8px;
     }
     .graph-btn{
       font-size:12px;
       line-height:1.2;
       color:#fff;
       background-color:rgba(255,255,255,0.07);
       border:1px solid rgba(255,255,255,0.3);
       border-radius:4px;
       padding:6px 8px;
       cursor:pointer;
     }
 
-    .graph-canvas{
-      position:absolute;
-      left:0;
-      top:0;
-      right:0;
-      bottom:0;
-      pointer-events:none;
-      overflow:hidden;
-    }
-
-    /* simple node preview dots */
-    .graph-node{
-      position:absolute;
-      width:60px;
-      height:60px;
-      border-radius:9999px;
-      background:rgba(255,255,255,0.08);
-      border:1px solid rgba(255,255,255,0.4);
-      box-shadow:0 10px 30px rgba(0,0,0,0.8);
-      color:#fff;
-      font-size:11px;
-      line-height:1.2;
-      text-align:center;
-      padding:8px;
-      display:flex;
-      flex-direction:column;
-      justify-content:center;
-      align-items:center;
-    }
-
-    .graph-node-title{
-      font-weight:500;
-      color:#fff;
-    }
-    .graph-node-sub{
-      color:rgba(255,255,255,0.6);
-      font-size:10px;
-      line-height:1.2;
-    }
-
-    /* fake lines */
-    .graph-link{
-      position:absolute;
-      border-top:1px solid rgba(255,255,255,0.3);
-      opacity:0.6;
-    }
+    .graph-canvas{
+      position:absolute;
+      inset:0;
+      overflow:hidden;
+      cursor:grab;
+    }
+
+    .graph-canvas:active{
+      cursor:grabbing;
+    }
+
+    .graph-tooltip{
+      position:absolute;
+      pointer-events:none;
+      background:rgba(17,17,17,0.85);
+      border:1px solid rgba(255,255,255,0.15);
+      border-radius:8px;
+      padding:8px 10px;
+      font-size:11px;
+      color:#fff;
+      box-shadow:0 12px 30px rgba(0,0,0,0.45);
+      opacity:0;
+      transform:translate(-50%,-140%);
+      transition:opacity 0.12s ease;
+      white-space:nowrap;
+    }
+
+    .graph-tooltip[data-visible="true"]{
+      opacity:1;
+    }
+
+    .graph-empty-hint{
+      position:absolute;
+      inset:0;
+      display:flex;
+      align-items:center;
+      justify-content:center;
+      color:rgba(255,255,255,0.45);
+      font-size:12px;
+      pointer-events:none;
+    }
+
+    .graph-controls .graph-btn[data-active="true"]{
+      background-color:rgba(255,255,255,0.2);
+      border-color:rgba(255,255,255,0.6);
+    }
   </style>
 </head>
 
 <body class="font-sans text-white bg-[var(--sb-main-top)] min-h-screen flex flex-col md:flex-row">
 
   <!-- LEFT SIDEBAR -->
   <aside
     id="sidebar"
     class="sidebar hidden md:flex flex-col shrink-0 select-none"
     data-collapsed="false"
   >
     <div class="brand-area border-b border-white/10 px-[16px] py-[20px]">
       <div class="brand-wrapper">
         <div id="brandToggleArea" class="brand-left">
           <div class="logo-wrapper">
             <img src="home_assets/logo.png" alt="FOR:WORD"/>
           </div>
 
           <div class="expand-icon-wrapper">
             <svg class="w-[16px] h-[16px] text-white/80" fill="none" stroke="currentColor" stroke-width="1.5"
               viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
               <path d="m9 6 6 6-6 6"/>
             </svg>
           </div>
 
@@ -574,87 +574,431 @@
       class="flex-1 overscroll-contain pb-[calc(var(--mobile-nav-h)+16px)] md:pb-[32px]"
       style="
         overflow-y:hidden;
         padding-top:15px;
         padding-left:40px;
         padding-right:32px;
       "
     >
       <div class="page-inner">
 
         <!-- HEADER -->
         <header class="mb-[24px] md:mb-[32px]">
           <div class="hero-title">
 Knowledge Graph
 See how everything connects.
           </div>
         </header>
 
         <!-- GRAPH PANEL -->
         <section class="graph-panel">
           <div class="graph-header-row">
             <div class="graph-header-left">
               <div class="graph-title">Your Knowledge Map</div>
               <div class="graph-meta">concepts, quotes, projects, all linked</div>
             </div>
-            <div class="graph-controls">
-              <button class="graph-btn">Similar</button>
-              <button class="graph-btn">Manual</button>
-              <button class="graph-btn">Focus</button>
-            </div>
-          </div>
-
-          <!-- fake nodes / links preview -->
-          <div class="graph-canvas">
-
-            <!-- link lines -->
-            <div class="graph-link" style="left:160px;top:200px;width:140px;transform:rotate(10deg);"></div>
-            <div class="graph-link" style="left:260px;top:140px;width:120px;transform:rotate(-30deg);"></div>
-            <div class="graph-link" style="left:320px;top:260px;width:150px;transform:rotate(20deg);"></div>
-
-            <!-- central node -->
-            <div class="graph-node" style="left:200px;top:200px;">
-              <div class="graph-node-title">사랑=감당</div>
-              <div class="graph-node-sub">core idea</div>
-            </div>
-
-            <div class="graph-node" style="left:330px;top:150px;">
-              <div class="graph-node-title">연애 심리</div>
-              <div class="graph-node-sub">essay</div>
-            </div>
-
-            <div class="graph-node" style="left:360px;top:290px;">
-              <div class="graph-node-title">세컨드<br/>브레인</div>
-              <div class="graph-node-sub">product</div>
-            </div>
-
-            <div class="graph-node" style="left:120px;top:260px;">
-              <div class="graph-node-title">커플 가계부</div>
-              <div class="graph-node-sub">app idea</div>
-            </div>
-
-          </div>
-        </section>
+            <div class="graph-controls">
+              <button class="graph-btn" id="btnSuggest">Similar</button>
+              <button class="graph-btn" id="btnManual" data-active="false">Manual</button>
+              <button class="graph-btn" id="btnFocus">Focus</button>
+            </div>
+          </div>
+
+          <div class="graph-canvas" id="graphCanvas">
+            <svg id="graphSvg" width="100%" height="100%" role="presentation"></svg>
+            <div class="graph-tooltip" id="graphTooltip"></div>
+            <div class="graph-empty-hint" id="graphEmptyHint" hidden>
+              더블 클릭하여 새 노드를 추가하거나 목록에서 선택하세요.
+            </div>
+          </div>
+        </section>
 
       </div>
     </section>
   </main>
 
-  <script>
-    // collapse/expand sidebar
-    const sidebar = document.getElementById('sidebar');
-    const collapseToggle = document.getElementById('collapseToggle');
-    const brandToggleArea = document.getElementById('brandToggleArea');
-
-    collapseToggle.addEventListener('click', () => {
-      sidebar.setAttribute('data-collapsed', 'true');
-    });
-
-    brandToggleArea.addEventListener('click', () => {
-      if (sidebar.getAttribute('data-collapsed') === 'true') {
-        sidebar.setAttribute('data-collapsed', 'false');
-      }
-    });
-  </script>
+  <script>
+    // collapse/expand sidebar
+    const sidebar = document.getElementById('sidebar');
+    const collapseToggle = document.getElementById('collapseToggle');
+    const brandToggleArea = document.getElementById('brandToggleArea');
+
+    collapseToggle.addEventListener('click', () => {
+      sidebar.setAttribute('data-collapsed', 'true');
+    });
+
+    brandToggleArea.addEventListener('click', () => {
+      if (sidebar.getAttribute('data-collapsed') === 'true') {
+        sidebar.setAttribute('data-collapsed', 'false');
+      }
+    });
+
+    // ==== graph interactions ====
+    const svg = d3.select('#graphSvg');
+    const canvasEl = document.getElementById('graphCanvas');
+    const tooltipEl = document.getElementById('graphTooltip');
+    const emptyHintEl = document.getElementById('graphEmptyHint');
+
+    const gRoot = svg.append('g');
+    const linkLayer = gRoot.append('g').attr('class', 'links');
+    const nodeLayer = gRoot.append('g').attr('class', 'nodes');
+
+    const initialRect = canvasEl.getBoundingClientRect();
+    svg.attr('viewBox', `${-initialRect.width / 2} ${-initialRect.height / 2} ${initialRect.width} ${initialRect.height}`);
+
+    const colorScale = d3.scaleOrdinal()
+      .domain(['core', 'idea', 'essay', 'product', 'quote'])
+      .range(['#FF8A65', '#F6C762', '#6EB5FF', '#A190FF', '#7BD88F']);
+
+    const initialNodes = [
+      { id: 'root', label: '사랑=감당', type: 'core', detail: '핵심 개념' },
+      { id: 'n1', label: '연애 심리', type: 'essay', detail: '연결된 글' },
+      { id: 'n2', label: '세컨드 브레인', type: 'product', detail: '프로젝트 노트' },
+      { id: 'n3', label: '커플 가계부', type: 'idea', detail: '아이디어 스케치' },
+      { id: 'n4', label: '사랑=책임', type: 'quote', detail: '인용문' }
+    ];
+
+    const initialLinks = [
+      { source: 'root', target: 'n1', kind: 'reference' },
+      { source: 'root', target: 'n2', kind: 'inspires' },
+      { source: 'root', target: 'n3', kind: 'inspires' },
+      { source: 'n1', target: 'n4', kind: 'supports' }
+    ];
+
+    let nodes = [...initialNodes];
+    let links = [...initialLinks];
+    let selectedNode = nodes[0];
+    let manualMode = false;
+    let nodeIdCounter = 10;
+
+    const simulation = d3.forceSimulation(nodes)
+      .force('link', d3.forceLink(links).id(d => d.id).distance(140).strength(0.9))
+      .force('charge', d3.forceManyBody().strength(-320))
+      .force('center', d3.forceCenter(0, 0))
+      .force('collision', d3.forceCollide().radius(60))
+      .alphaDecay(0.05)
+      .on('tick', ticked);
+
+    const zoom = d3.zoom()
+      .scaleExtent([0.3, 2.5])
+      .on('zoom', (event) => {
+        gRoot.attr('transform', event.transform);
+      });
+
+    svg.call(zoom);
+    svg.on('dblclick.zoom', null);
+
+    const dragBehaviour = d3.drag()
+      .on('start', function(event, d) {
+        if (!event.active && !manualMode) {
+          simulation.alphaTarget(0.3).restart();
+        }
+        d.fx = d.x;
+        d.fy = d.y;
+      })
+      .on('drag', function(event, d) {
+        d.fx = event.x;
+        d.fy = event.y;
+        if (manualMode) {
+          d.x = event.x;
+          d.y = event.y;
+          ticked();
+        }
+      })
+      .on('end', function(event, d) {
+        if (!event.active && !manualMode) {
+          simulation.alphaTarget(0);
+        }
+        if (manualMode) {
+          d.fx = d.x;
+          d.fy = d.y;
+          return;
+        }
+        d.fx = null;
+        d.fy = null;
+      });
+
+    function updateGraph() {
+      emptyHintEl.hidden = nodes.length > 0;
+
+      const linkJoin = linkLayer.selectAll('line')
+        .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
+        .join(
+          enter => enter.append('line')
+            .attr('stroke-width', 1.4)
+            .attr('opacity', 0.75),
+          update => update,
+          exit => exit.remove()
+        )
+        .attr('stroke-dasharray', d => d.kind === 'supports' ? '6 4' : null)
+        .attr('stroke', 'rgba(255,255,255,0.3)');
+
+      const nodeJoin = nodeLayer.selectAll('g')
+        .data(nodes, d => d.id)
+        .join(
+          enter => {
+            const nodeGroup = enter.append('g')
+              .attr('role', 'button')
+              .attr('tabindex', 0)
+              .attr('data-id', d => d.id)
+              .attr('aria-label', d => `${d.label} 노드`)
+              .attr('transform', 'scale(0.8)')
+              .style('cursor', 'pointer')
+              .call(dragBehaviour)
+              .on('click', (event, d) => {
+                event.stopPropagation();
+                selectNode(d);
+              })
+              .on('mouseenter', (event, d) => showTooltip(event, d))
+              .on('mouseleave', hideTooltip)
+              .on('focus', (event, d) => showTooltip(event, d))
+              .on('blur', hideTooltip);
+
+            nodeGroup.append('circle')
+              .attr('r', 36)
+              .attr('stroke-width', 1.5)
+              .attr('filter', 'url(#nodeShadow)');
+
+            nodeGroup.append('text')
+              .attr('class', 'node-title')
+              .attr('text-anchor', 'middle')
+              .attr('dy', '-0.2em')
+              .attr('fill', '#fff')
+              .attr('font-size', 11.5)
+              .attr('font-weight', 500);
+
+            nodeGroup.append('text')
+              .attr('class', 'node-detail')
+              .attr('text-anchor', 'middle')
+              .attr('dy', '2.3em')
+              .attr('fill', 'rgba(255,255,255,0.6)')
+              .attr('font-size', 9.5);
+
+            return nodeGroup;
+          },
+          update => update,
+          exit => exit.remove()
+        );
+
+      nodeJoin.select('circle')
+        .attr('fill', d => {
+          const base = d3.color(colorScale(d.type) || '#6EB5FF');
+          if (!base) return 'rgba(110,181,255,0.18)';
+          const copy = base.copy();
+          copy.opacity = 0.18;
+          return copy.formatRgb();
+        })
+        .attr('stroke', d => colorScale(d.type) || '#6EB5FF');
+
+      nodeJoin.select('.node-title').each(function(d) {
+        const labelLines = d.label.split(/\s|\\n/);
+        const textSel = d3.select(this).selectAll('tspan')
+          .data(labelLines, (line, i) => `${line}-${i}`);
+        textSel.join(
+          enter => enter.append('tspan'),
+          update => update,
+          exit => exit.remove()
+        )
+          .attr('x', 0)
+          .attr('dy', (line, i) => (i === 0 ? 0 : '1.2em'))
+          .text(line => line);
+      });
+
+      nodeJoin.select('.node-detail')
+        .text(d => d.detail);
+
+      applySelectionStyles();
+
+      if (!manualMode) {
+        simulation.nodes(nodes);
+        simulation.force('link').links(links);
+        simulation.alpha(0.8).restart();
+      }
+    }
+
+    function ticked() {
+      linkLayer.selectAll('line')
+        .attr('x1', d => d.source.x)
+        .attr('y1', d => d.source.y)
+        .attr('x2', d => d.target.x)
+        .attr('y2', d => d.target.y);
+
+      nodeLayer.selectAll('g')
+        .attr('transform', d => `translate(${d.x},${d.y})`);
+    }
+
+    function showTooltip(event, node) {
+      const canvasRect = canvasEl.getBoundingClientRect();
+      const targetRect = event.currentTarget.getBoundingClientRect();
+      const pointerX = event.clientX || (targetRect.left + targetRect.width / 2);
+      const pointerY = event.clientY || targetRect.top;
+      tooltipEl.textContent = `${node.label} · ${node.detail}`;
+      tooltipEl.style.left = `${pointerX - canvasRect.left}px`;
+      tooltipEl.style.top = `${pointerY - canvasRect.top}px`;
+      tooltipEl.dataset.visible = 'true';
+    }
+
+    function hideTooltip() {
+      tooltipEl.dataset.visible = 'false';
+    }
+
+    function selectNode(node) {
+      selectedNode = node;
+      applySelectionStyles();
+    }
+
+    function applySelectionStyles() {
+      nodeLayer.selectAll('g')
+        .attr('opacity', d => {
+          if (!selectedNode) return 1;
+          if (d.id === selectedNode.id) return 1;
+          return 0.45;
+        })
+        .select('circle')
+        .attr('stroke-width', d => selectedNode && d.id === selectedNode.id ? 2.4 : 1.5);
+
+      linkLayer.selectAll('line')
+        .attr('stroke', d => {
+          const sourceId = typeof d.source === 'string' ? d.source : d.source.id;
+          const targetId = typeof d.target === 'string' ? d.target : d.target.id;
+          if (!selectedNode) return 'rgba(255,255,255,0.35)';
+          const isActive = sourceId === selectedNode.id || targetId === selectedNode.id;
+          return isActive ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.2)';
+        })
+        .attr('stroke-width', d => {
+          const sourceId = typeof d.source === 'string' ? d.source : d.source.id;
+          const targetId = typeof d.target === 'string' ? d.target : d.target.id;
+          if (!selectedNode) return 1.4;
+          const isActive = sourceId === selectedNode.id || targetId === selectedNode.id;
+          return isActive ? 2 : 1.2;
+        })
+        .attr('opacity', d => {
+          const sourceId = typeof d.source === 'string' ? d.source : d.source.id;
+          const targetId = typeof d.target === 'string' ? d.target : d.target.id;
+          if (!selectedNode) return 0.7;
+          const isActive = sourceId === selectedNode.id || targetId === selectedNode.id;
+          return isActive ? 0.95 : 0.35;
+        });
+    }
+
+    function addSuggestion() {
+      const base = selectedNode || nodes[0];
+      if (!base) return;
+
+      const newId = `n${nodeIdCounter++}`;
+      const suggestionTypes = ['quote', 'idea', 'essay'];
+      const randomType = suggestionTypes[Math.floor(Math.random() * suggestionTypes.length)];
+      const randomLabels = {
+        quote: ['공감의 말', '가치관 메모', '인터뷰 구절'],
+        idea: ['새로운 실험', '후속 프로젝트', '테스트 가설'],
+        essay: ['심화 기록', '리뷰 초안', '분석 노트']
+      };
+
+      const newNode = {
+        id: newId,
+        label: randomLabels[randomType][Math.floor(Math.random() * 3)],
+        type: randomType,
+        detail: `${base.label} 연관`,
+        x: base.x + (Math.random() * 120 - 60),
+        y: base.y + (Math.random() * 120 - 60)
+      };
+
+      nodes.push(newNode);
+      links.push({ source: base.id, target: newId, kind: 'suggested' });
+      selectNode(newNode);
+      manualMode = false;
+      const manualBtn = document.getElementById('btnManual');
+      manualBtn.dataset.active = 'false';
+      manualBtn.textContent = 'Manual';
+      updateGraph();
+    }
+
+    function toggleManual() {
+      manualMode = !manualMode;
+      const btn = document.getElementById('btnManual');
+      btn.dataset.active = manualMode ? 'true' : 'false';
+      btn.textContent = manualMode ? 'Auto' : 'Manual';
+
+      if (manualMode) {
+        simulation.stop();
+        nodes.forEach(node => {
+          node.fx = node.x;
+          node.fy = node.y;
+        });
+      } else {
+        nodes.forEach(node => {
+          node.fx = null;
+          node.fy = null;
+        });
+        simulation.alpha(0.6).restart();
+      }
+      applySelectionStyles();
+    }
+
+    function focusSelected() {
+      if (!selectedNode) return;
+      const { x, y } = selectedNode;
+      const transition = svg.transition().duration(450);
+      transition.call(zoom.transform, d3.zoomIdentity.translate(canvasEl.clientWidth / 2, canvasEl.clientHeight / 2).scale(1.2).translate(-x, -y));
+    }
+
+    document.getElementById('btnSuggest').addEventListener('click', addSuggestion);
+    document.getElementById('btnManual').addEventListener('click', toggleManual);
+    document.getElementById('btnFocus').addEventListener('click', focusSelected);
+
+    canvasEl.addEventListener('click', (event) => {
+      if (event.target === svg.node()) {
+        selectedNode = null;
+        applySelectionStyles();
+        hideTooltip();
+      }
+    });
+
+    canvasEl.addEventListener('dblclick', (event) => {
+      const pointer = d3.pointer(event, svg.node());
+      const transform = d3.zoomTransform(svg.node());
+      const [x, y] = transform.invert(pointer);
+      const newId = `n${nodeIdCounter++}`;
+      nodes.push({
+        id: newId,
+        label: '새 노드',
+        type: 'idea',
+        detail: '수동 추가',
+        x,
+        y
+      });
+      selectNode(nodes[nodes.length - 1]);
+      updateGraph();
+    });
+
+    const resizeObserver = new ResizeObserver(() => {
+      const { clientWidth, clientHeight } = canvasEl;
+      svg.attr('viewBox', `${-clientWidth / 2} ${-clientHeight / 2} ${clientWidth} ${clientHeight}`);
+      simulation.force('center', d3.forceCenter(0, 0));
+      if (!manualMode) {
+        simulation.alpha(0.6).restart();
+      }
+    });
+
+    resizeObserver.observe(canvasEl);
+
+    // shadow filter definition
+    const defs = svg.append('defs');
+    const filter = defs.append('filter')
+      .attr('id', 'nodeShadow')
+      .attr('x', '-50%')
+      .attr('y', '-50%')
+      .attr('width', '200%')
+      .attr('height', '200%');
+
+    filter.append('feDropShadow')
+      .attr('dx', 0)
+      .attr('dy', 12)
+      .attr('stdDeviation', 14)
+      .attr('flood-color', 'rgba(0,0,0,0.6)');
+
+    updateGraph();
+    selectNode(selectedNode);
+  </script>
 
 </body>
 </html>
