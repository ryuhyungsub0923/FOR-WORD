diff --git a/editor.html b/editor.html
index 25872528d66bd491a5042299923e530663074af0..32491dca2a1ed6fe30ae021f84d7fa79131edc41 100644
--- a/editor.html
+++ b/editor.html
@@ -406,152 +406,156 @@ FILE: editor.html
         <div>
           <div class="memo-sect-head">BMC 요약 (읽기 전용)</div>
           <div id="bmcGrid" class="bmc-grid"></div>
         </div>
         <div>
           <div class="memo-sect-head">내 메모</div>
           <div id="userMemoList" class="memo-grid"></div>
         </div>
       </div>
 
       <div class="memo-bar">
         <div class="memo-info">BMC는 읽기 전용 · 내 메모는 자동 저장</div>
         <button id="memoAddBtn" class="memo-add">+ 메모 추가</button>
       </div>
     </section>
 
     <!-- 추천 -->
     <section id="panel-reco" class="panel" role="tabpanel">
       <div class="bmc-card">
         <div class="bmc-title">추천 노트</div>
         <div>작성 중…</div>
       </div>
     </section>
   </aside>
 
-  <script>
-    /* ===== Polyfills ===== */
-    (function(){ // CSS.escape
-      if (typeof window.CSS === "undefined") window.CSS = {};
-      if (!window.CSS.escape){
-        window.CSS.escape = function(value){
+  <script type="module">
+    import { DataStore } from './editor_assets/data-store.js';
+    import { splitIntoChunks } from './editor_assets/chunk-utils.js';
+    import { EditorEvents, emitEditorEvent, onEditorEvent } from './editor_assets/event-hooks.js';
+
+    /* ===== Polyfills ===== */
+    (function(){ // CSS.escape
+      if (typeof window.CSS === "undefined") window.CSS = {};
+      if (!window.CSS.escape){
+        window.CSS.escape = function(value){
           if (arguments.length === 0) throw new TypeError('`CSS.escape` requires an argument.');
           var string = String(value); var length = string.length; var index = -1; var codeUnit, result = ''; var firstCodeUnit = string.charCodeAt(0);
           while (++index < length){
             codeUnit = string.charCodeAt(index);
             if (codeUnit === 0x0000){ result += "\uFFFD"; continue; }
             if ((codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit === 0x007F || (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) || (index === 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit === 0x002D)){
               result += "\\" + codeUnit.toString(16) + " "; continue;
             }
             if (index === 0 && codeUnit === 0x002D && length === 1){ result += "\\" + string.charAt(index); continue; }
             if (codeUnit >= 0x0080 || codeUnit === 0x002D || codeUnit === 0x005F || (codeUnit >= 0x0030 && codeUnit <= 0x0039) || (codeUnit >= 0x0041 && codeUnit <= 0x005A) || (codeUnit >= 0x0061 && codeUnit <= 0x007A)){
               result += string.charAt(index); continue;
             }
             result += "\\" + string.charAt(index);
           }
           return result;
         };
       }
     })();
 
-    const rIC = window.requestIdleCallback || function(cb){ return setTimeout(cb, 1); };
-
-    /* ===== Keys/State ===== */
-    const LIST_KEY    = 'fw_projects';
-    const DRAFT_KEY   = 'fw_project_draft_v2';
-    const LAST_ID_KEY = 'fw_last_project_id';
-    const LAST_NODE_GLOBAL = 'fw_last_node_global';
-    function MEMO_KEY(pid){ return `fw_user_memos_${pid}`; }
-    function docsKey(pid){ return `fw_docs_${pid}`; }
-    function lastNodeKey(pid){ return `fw_last_node_${pid}`; }
-    function tagKeyFor(pid, pathSub){ return `fw_editor_tags_${pid}::${pathSub}`; }
-    function tocStateKey(pid){ return `fw_toc_state_${pid}`; }
-
-    let CURRENT_PROJECT = null;
-    let CURRENT_PID = null;
-    let CURRENT_NODE_PATH = null;
-    let SUSPEND_SAVE = 0;
-    const PAGE = { enabled: true, pendingReflow:false };
+    const rIC = window.requestIdleCallback || function(cb){ return setTimeout(cb, 1); };
+
+    /* ===== Keys/State ===== */
+    const LAST_ID_KEY = 'fw_last_project_id';
+    const LAST_NODE_GLOBAL = 'fw_last_node_global';
+    function tocStateKey(pid){ return `fw_toc_state_${pid}`; }
+    function lastNodeKey(pid){ return `fw_last_node_${pid}`; }
+
+    const store = new DataStore(window.localStorage);
+    const SNAPSHOT_INTERVAL = 5 * 60 * 1000;
+
+    window.FWEditorEvents = Object.freeze({
+      emit: emitEditorEvent,
+      on: onEditorEvent,
+      events: EditorEvents
+    });
+
+    let CURRENT_PROJECT = null;
+    let CURRENT_PID = null;
+    let CURRENT_NODE_PATH = null;
+    let CURRENT_NOTE = null;
+    let SNAPSHOT_TIMER = null;
+    let SUSPEND_SAVE = 0;
+    const PAGE = { enabled: true, pendingReflow:false };
 
     /* ===== Utils ===== */
     function safeParse(json, fallback){
       try{ const v = JSON.parse(json); return (v === null || v === undefined) ? fallback : v; }
       catch(_){ return fallback; }
     }
     function htmlToText(html){ const tmp = document.createElement('div'); tmp.innerHTML = html || ''; return (tmp.textContent || '').trim(); }
     function escapeHTML(t){ return String(t||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
     function textToHTML(t){ return escapeHTML(t||'').replace(/\n/g,'<br/>'); }
-    function toastOnce(msg){ if (!window.toast) return alert(msg); window.toast(msg); }
-    function getProjectList(){ return safeParse(localStorage.getItem(LIST_KEY), []); }
-    function getDraft(){ return safeParse(localStorage.getItem(DRAFT_KEY), null); }
-    function getProjectById(pid){
-      const list=getProjectList();
-      return list.find(p=>p?.id===pid) || (getDraft()?.id===pid ? getDraft() : null);
-    }
+    function toastOnce(msg){ if (!window.toast) return alert(msg); window.toast(msg); }
+    function getProjectList(){ return store.listProjects(); }
+    function getProjectById(pid){ return store.getProject(pid); }
     function splitFullPath(full){ const i = full.indexOf('::'); if (i<0) return [CURRENT_PID, full]; return [full.slice(0,i), full.slice(i+2)]; }
 
     /* ===== Sidebar ===== */
     function initSidebar(){
       const sidebar = document.getElementById('sidebar');
       const collapseToggle = document.getElementById('collapseToggle');
       const brandToggleArea = document.getElementById('brandToggleArea');
       collapseToggle?.addEventListener('click', () => sidebar.setAttribute('data-collapsed', 'true'));
       brandToggleArea?.addEventListener('click', () => { if (sidebar.getAttribute('data-collapsed') === 'true') sidebar.setAttribute('data-collapsed', 'false'); });
     }
 
     /* ===== TOC ===== */
     const BMC_LABELS = [
       ['cs','고객 세분화'], ['cr','고객 관계'], ['ch','채널'],
       ['rs','수익 모델'], ['vp','가치 제안'], ['ka','핵심 활동'],
       ['kr','핵심 자원'], ['kp','핵심 파트너'], ['cst','비용 구조'],
     ];
     function buildTocNodesForProject(p){
       const pid = p.id;
       const title = (p?.title || '무제 프로젝트').trim();
       const psst  = p?.psst || {};
       const trim = (s)=> (String(s||'').replace(/\s+/g,' ').trim() || '—').slice(0,50);
       const root = { pid, path:`${pid}::project`, type:'project', title:`${title}`, children:[] };
       const psGroup = {
         pid, path:`${pid}::psst`, type:'psstGroup', title:'PSST', isFolder:true, children:[
           { pid, path:`${pid}::psst/p`,  type:'psstP', title:`P: ${trim(psst.p)}`,  children:[] },
           { pid, path:`${pid}::psst/s1`, type:'psstS', title:`S: ${trim(psst.s1 ?? psst.s)}`, children:[] },
           { pid, path:`${pid}::psst/s2`, type:'psstS', title:`S: ${trim(psst.s2)}`, children:[] },
           { pid, path:`${pid}::psst/t`,  type:'psstT', title:`T: ${trim(psst.t)}`,  children:[] },
         ]
       };
       root.children.push(psGroup);
       root.children.push({ pid, path:`${pid}::background`, type:'background', title:`배경`, children:[] });
       return [root];
     }
-    function buildAllTocNodes(){
-      const nodes = [];
-      const list = getProjectList();
-      list.forEach(p => nodes.push(...buildTocNodesForProject(p)));
-      const d = getDraft();
-      if (d && !list.find(x=>x.id===d.id)){ nodes.push(...buildTocNodesForProject(d)); }
-      return nodes;
-    }
+    function buildAllTocNodes(){
+      const nodes = [];
+      const list = getProjectList();
+      list.forEach(p => nodes.push(...buildTocNodesForProject(p)));
+      return nodes;
+    }
     function renderTocTree(nodes){
       const root = document.getElementById('tocRoot'); if(!root) return; root.innerHTML = '';
       function badgeText(t){ const m = { project:'Project', psstGroup:'PSST', background:'BG', psstP:'P', psstS:'S', psstT:'T' }; return m[t] || t; }
       function buildItem(node){
         const hasChildren = !!(node.children && node.children.length);
         const isFolder = !!node.isFolder;
         const state = safeParse(localStorage.getItem(tocStateKey(node.pid)), {});
         const expanded = state[node.path] !== false;
 
         const box = document.createElement('div');
         box.className = 'node';
         box.dataset.path = node.path;
         box.dataset.type = node.type;
         box.dataset.pid  = node.pid;
         if (CURRENT_NODE_PATH === node.path) box.classList.add('is-active');
 
         const caretEl = document.createElement('span'); caretEl.className = 'caret'; caretEl.textContent = hasChildren ? (expanded ? '▾' : '▸') : '·';
         const badgeEl = document.createElement('span'); badgeEl.className = 'badge'; badgeEl.textContent = badgeText(node.type);
         const titleEl = document.createElement('span'); titleEl.className = 'title'; titleEl.textContent = node.title || '(제목없음)';
         box.appendChild(caretEl); box.appendChild(badgeEl); box.appendChild(titleEl);
 
         const wrapEl = document.createElement('div'); wrapEl.className = 'toc-item' + (expanded?'':' is-collapsed');
         const liEl = document.createElement('div'); liEl.className = 'toc-li'; liEl.appendChild(box);
 
         if (hasChildren){
@@ -563,234 +567,266 @@ FILE: editor.html
         wrapEl.appendChild(liEl);
 
         box.addEventListener('click', (ev)=>{
           const clickOnCaret = (ev.offsetX <= 22);
           if (hasChildren && (clickOnCaret || isFolder)){
             const collapsed = liEl.classList.toggle('is-collapsed');
             caretEl.textContent = collapsed ? '▸' : '▾';
             const s = safeParse(localStorage.getItem(tocStateKey(node.pid)), {}) || {};
             s[node.path] = !collapsed; localStorage.setItem(tocStateKey(node.pid), JSON.stringify(s));
           }else{
             openNodeDocument(node.path, node.title, node.pid);
             document.querySelectorAll('.node.is-active').forEach(n=> n.classList.remove('is-active'));
             box.classList.add('is-active');
           }
         });
         return wrapEl;
       }
       nodes.forEach(n => root.appendChild(buildItem(n)));
     }
     function rerenderToc(){
       renderTocTree(buildAllTocNodes());
       const active = document.querySelector(`.node[data-path="${CSS.escape(CURRENT_NODE_PATH||'')}"]`);
       if (active){ document.querySelectorAll('.node.is-active').forEach(n=> n.classList.remove('is-active')); active.classList.add('is-active'); }
     }
 
-    /* ===== Docs ===== */
-    function loadDocsMap(pid){ return safeParse(localStorage.getItem(docsKey(pid)), {}); }
-    function saveDocsMap(pid, map){ localStorage.setItem(docsKey(pid), JSON.stringify(map||{})); }
-    function persistProject(){
-      try{
-        if (!CURRENT_PID || !CURRENT_PROJECT) return;
-        const d = getDraft();
-        if (d && d.id === CURRENT_PID){
-          localStorage.setItem(DRAFT_KEY, JSON.stringify({ ...d, ...CURRENT_PROJECT, savedAt:new Date().toISOString() }));
-        }
-        const list = getProjectList();
-        const idx = list.findIndex(x=> x && x.id === CURRENT_PID);
-        if (idx>=0){
-          list[idx] = { ...list[idx], ...CURRENT_PROJECT, savedAt:new Date().toISOString() };
-          localStorage.setItem(LIST_KEY, JSON.stringify(list));
-        }
-        localStorage.setItem(LAST_ID_KEY, CURRENT_PID);
-      }catch(e){ console.error(e); }
-    }
+    function persistProject(patch){
+      if (!CURRENT_PID) return;
+      const base = CURRENT_PROJECT ? { ...CURRENT_PROJECT } : {};
+      const merged = patch ? { ...base, ...patch } : base;
+      const updated = store.updateProject(CURRENT_PID, merged);
+      if (updated){ CURRENT_PROJECT = updated; }
+      if (CURRENT_PID){ localStorage.setItem(LAST_ID_KEY, CURRENT_PID); }
+    }
 
     /* ===== Editor refs ===== */
     const editor = { pageRoot:null, title:null, saveBtn:null, tagRow:null, addTagBtn:null };
 
     function defaultDocHtml(title){
       const h = (t)=> (t||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
       return `<section class="page" contenteditable="true"><h2>${h(title||'')}</h2>\n<p></p></section>`;
     }
     function psstInitialHtmlFor(subpath, project){
       const key = subpath.split('/')[1];
       const label = {p:'Problem', s1:'Solution', s2:'Strategy', t:'Timeline'}[key] || 'PSST';
       const val = (project?.psst?.[key] || '').trim();
       return `<section class="page" contenteditable="true"><h2>${label}</h2>\n<p>${textToHTML(val)}</p></section>`;
     }
     function ensureAtLeastOnePage(){
       const root = editor.pageRoot;
       if (!root) return;
       if (!root.querySelector('.page')){
         const sec = document.createElement('section');
         sec.className = 'page';
         sec.setAttribute('contenteditable','true');
         root.appendChild(sec);
       }
       root.dataset.pageView = PAGE.enabled ? 'true' : 'false';
       root.classList.remove('editor-placeholder');
       if (root.querySelectorAll('.page').length === 1 && root.querySelector('.page').innerHTML.trim()===''){
         root.classList.add('editor-placeholder');
       }
     }
 
-    function openNodeDocument(fullPath, displayTitle, pidFromNode){
-      const [pid, sub] = splitFullPath(fullPath);
-      const targetPid = pidFromNode || pid;
-
-      // 폴더 가드: 'psst'는 폴더이므로 열지 않음
-      if (sub === 'psst'){ return; }
-
-      const proj = getProjectById(targetPid);
-      if (!proj){ toastOnce('프로젝트를 찾을 수 없습니다.'); return; }
-      CURRENT_PROJECT = proj; CURRENT_PID = targetPid;
-
-      CURRENT_NODE_PATH = `${CURRENT_PID}::${sub}`;
-      localStorage.setItem(LAST_ID_KEY, CURRENT_PID);
-      localStorage.setItem(LAST_NODE_GLOBAL, CURRENT_NODE_PATH);
-      localStorage.setItem(lastNodeKey(CURRENT_PID), CURRENT_NODE_PATH);
-
-      const map = loadDocsMap(CURRENT_PID);
-      if (!map[sub]){
-        const isPS = sub.startsWith('psst/');
-        const content = isPS ? psstInitialHtmlFor(sub, CURRENT_PROJECT) : defaultDocHtml(displayTitle || sub);
-        map[sub] = { title: displayTitle || sub, html: content, type: sub.split('/')[0], updatedAt: new Date().toISOString() };
-        saveDocsMap(CURRENT_PID, map);
-        toastOnce('새 문서를 생성했습니다');
-      }
-
-      const doc = map[sub];
-      editor.title.value = doc.title || '';
-      editor.pageRoot.innerHTML = doc.html || '';
-      ensureAtLeastOnePage();
-      updatePageDividers();
-
-      renderTagsFor(CURRENT_PID, sub);
-      renderBmcCards();
-      renderUserMemos();
-      rerenderToc();
-      if (PAGE.enabled) reflowPagesDeferred();
-    }
-
-    function saveCurrentDoc(){
-      if (SUSPEND_SAVE>0) return;
-      if (!CURRENT_NODE_PATH || !CURRENT_PID) return;
-      const [, sub] = splitFullPath(CURRENT_NODE_PATH);
-      const map = loadDocsMap(CURRENT_PID);
-      const doc = map[sub] || { title:'', html:'', type: sub.split('/')[0] };
-      doc.title = editor.title.value || '';
-      doc.html  = editor.pageRoot.innerHTML || '';
-      doc.updatedAt = new Date().toISOString();
-      map[sub] = doc;
-      saveDocsMap(CURRENT_PID, map);
-
-      if (sub.startsWith('psst/')){
-        const k = sub.split('/')[1];
-        const firstPage = editor.pageRoot.querySelector('.page');
-        const text = htmlToText(firstPage ? firstPage.innerHTML : doc.html);
-        if (!CURRENT_PROJECT.psst) CURRENT_PROJECT.psst = {};
-        CURRENT_PROJECT.psst[k] = text;
-        persistProject();
-        rerenderToc();
-      }
-
-      if (editor.saveBtn){
-        const old = editor.saveBtn.textContent;
-        editor.saveBtn.textContent = '저장됨';
-        setTimeout(()=> editor.saveBtn.textContent = old || '저장', 700);
-      }
-    }
-    const autosave = (()=>{ let t=null; return ()=>{ if (SUSPEND_SAVE>0) return; clearTimeout(t); t=setTimeout(saveCurrentDoc, 400); }; })();
+    function openNodeDocument(fullPath, displayTitle, pidFromNode){
+      const [pid, sub] = splitFullPath(fullPath);
+      const targetPid = pidFromNode || pid;
+
+      // 폴더 가드: 'psst'는 폴더이므로 열지 않음
+      if (sub === 'psst'){ return; }
+
+      const proj = getProjectById(targetPid);
+      if (!proj){ toastOnce('프로젝트를 찾을 수 없습니다.'); return; }
+      CURRENT_PROJECT = proj; CURRENT_PID = targetPid;
+
+      CURRENT_NODE_PATH = `${CURRENT_PID}::${sub}`;
+      localStorage.setItem(LAST_ID_KEY, CURRENT_PID);
+      localStorage.setItem(LAST_NODE_GLOBAL, CURRENT_NODE_PATH);
+      localStorage.setItem(lastNodeKey(CURRENT_PID), CURRENT_NODE_PATH);
+      store.setLastVisited(CURRENT_PID, CURRENT_NODE_PATH);
+
+      const existed = !!store.getNoteByPath(CURRENT_PID, sub);
+      const docType = sub.split('/')[0];
+      const isPS = sub.startsWith('psst/');
+      const note = store.ensureNote(CURRENT_PID, sub, {
+        title: displayTitle || sub,
+        doc_type: docType,
+        html: isPS ? psstInitialHtmlFor(sub, CURRENT_PROJECT) : defaultDocHtml(displayTitle || sub)
+      });
+      CURRENT_NOTE = note;
+      if (!existed){ toastOnce('새 문서를 생성했습니다'); }
+
+      editor.title.value = note.title || '';
+      editor.pageRoot.innerHTML = note.html || '';
+      ensureAtLeastOnePage();
+      updatePageDividers();
+
+      renderTagsFor(CURRENT_PID, sub);
+      renderBmcCards();
+      renderUserMemos();
+      rerenderToc();
+      if (PAGE.enabled) reflowPagesDeferred();
+
+      restartSnapshotTimer();
+      emitEditorEvent(EditorEvents.NOTE_OPENED, { project_id: CURRENT_PID, note_id: note.note_id, path: sub });
+    }
+
+    function restartSnapshotTimer(){
+      if (SNAPSHOT_TIMER){ clearInterval(SNAPSHOT_TIMER); SNAPSHOT_TIMER = null; }
+      if (!CURRENT_NOTE) return;
+      SNAPSHOT_TIMER = setInterval(()=>{
+        saveCurrentDoc({ manual:false, createVersion:true, versionType:'auto', versionLabel:'자동 스냅샷', skipDuplicate:true });
+      }, SNAPSHOT_INTERVAL);
+    }
+
+    function saveCurrentDoc(options = {}){
+      if (SUSPEND_SAVE>0) return;
+      if (!CURRENT_NODE_PATH || !CURRENT_PID || !CURRENT_NOTE) return;
+      const [, sub] = splitFullPath(CURRENT_NODE_PATH);
+      const title = editor.title.value || '';
+      const html = editor.pageRoot.innerHTML || '';
+      const text = htmlToText(html);
+      const chunkInfos = splitIntoChunks(text, { targetLength:800, tolerance:200, overlap:80 });
+      const updatedNote = store.updateNote(CURRENT_NOTE.note_id, {
+        title,
+        html,
+        text,
+        chunkInfos
+      });
+      if (updatedNote){ CURRENT_NOTE = updatedNote; }
+
+      if (sub.startsWith('psst/')){
+        const k = sub.split('/')[1];
+        const firstPage = editor.pageRoot.querySelector('.page');
+        const textForPsst = htmlToText(firstPage ? firstPage.innerHTML : html);
+        const next = { ...(CURRENT_PROJECT?.psst || {}), [k]: textForPsst };
+        CURRENT_PROJECT = { ...(CURRENT_PROJECT || {}), psst: next };
+        persistProject();
+        rerenderToc();
+      }
+
+      if (options.createVersion){
+        const version = store.recordVersion(CURRENT_NOTE.note_id, {
+          html,
+          label: options.versionLabel || (options.manual ? '수동 저장' : '자동 스냅샷'),
+          type: options.versionType || (options.manual ? 'manual' : 'auto'),
+          manual: !!options.manual,
+          skipDuplicate: options.skipDuplicate
+        });
+        if (version){
+          emitEditorEvent(EditorEvents.VERSION_CREATED, {
+            project_id: CURRENT_PID,
+            note_id: CURRENT_NOTE.note_id,
+            version_id: version.version_id,
+            type: version.type
+          });
+        }
+      }
+
+      emitEditorEvent(EditorEvents.NOTE_SAVED, {
+        project_id: CURRENT_PID,
+        note_id: CURRENT_NOTE.note_id,
+        manual: !!options.manual
+      });
+
+      const refreshedProject = getProjectById(CURRENT_PID);
+      if (refreshedProject){ CURRENT_PROJECT = refreshedProject; }
+
+      restartSnapshotTimer();
+
+      if (options.manual && editor.saveBtn){
+        const old = editor.saveBtn.textContent;
+        editor.saveBtn.textContent = '저장됨';
+        setTimeout(()=> editor.saveBtn.textContent = old || '저장', 700);
+      }
+    }
+    const autosave = (()=>{ let t=null; return ()=>{ if (SUSPEND_SAVE>0) return; clearTimeout(t); t=setTimeout(()=> saveCurrentDoc({}), 400); }; })();
 
     /* ===== 태그 ===== */
-    function renderTagsFor(pid, subpath){
-      const tagRow = editor.tagRow;
-      const addBtn = editor.addTagBtn;
-      Array.from(tagRow.querySelectorAll('.tag-pill')).forEach(n=> n.remove());
-      const TAGS = safeParse(localStorage.getItem(tagKeyFor(pid, subpath)), []);
-      TAGS.forEach((t, i)=>{
-        const b = document.createElement('button');
-        b.className='tag-pill'; b.textContent = t;
-        b.addEventListener('click', ()=> b.classList.toggle('active'));
-        b.addEventListener('dblclick', ()=>{
-          const arr = safeParse(localStorage.getItem(tagKeyFor(pid, subpath)), []);
-          arr.splice(i,1);
-          localStorage.setItem(tagKeyFor(pid, subpath), JSON.stringify(arr));
-          renderTagsFor(pid, subpath);
-        });
-        tagRow.insertBefore(b, addBtn);
-      });
-    }
+    function renderTagsFor(pid, subpath){
+      const tagRow = editor.tagRow;
+      const addBtn = editor.addTagBtn;
+      Array.from(tagRow.querySelectorAll('.tag-pill')).forEach(n=> n.remove());
+      const tags = store.getTags(pid, subpath);
+      tags.forEach((t, i)=>{
+        const b = document.createElement('button');
+        b.className='tag-pill'; b.textContent = t;
+        b.addEventListener('click', ()=> b.classList.toggle('active'));
+        b.addEventListener('dblclick', ()=>{
+          store.removeTag(pid, subpath, i);
+          renderTagsFor(pid, subpath);
+        });
+        tagRow.insertBefore(b, addBtn);
+      });
+    }
 
     /* ===== Right tabs/chat/memo ===== (원형 유지) */
     function initTabs(){
       const map = [['tab-chat','panel-chat'],['tab-memo','panel-memo'],['tab-reco','panel-reco'],];
       function activate(id){
         map.forEach(([b,p])=>{
           const btn = document.getElementById(b);
           const pan = document.getElementById(p);
           const on = (b===id);
           btn && btn.setAttribute('aria-selected', on?'true':'false');
           pan && pan.setAttribute('data-active', on?'true':'false');
         });
       }
       map.forEach(([b])=>{ const btn = document.getElementById(b); btn && btn.addEventListener('click', ()=>activate(b)); });
       activate('tab-chat');
     }
-    function loadUserMemos(){ return safeParse(localStorage.getItem(MEMO_KEY(CURRENT_PID)), []); }
-    function saveUserMemos(list){ localStorage.setItem(MEMO_KEY(CURRENT_PID), JSON.stringify(list||[])); }
+    function loadUserMemos(){ return CURRENT_PID ? store.listMemos(CURRENT_PID) : []; }
     function autoGrow(ta){ if (!ta) return; const minPx = parseInt(getComputedStyle(ta).minHeight, 10) || 66; ta.style.height = 'auto'; ta.style.height = Math.max(ta.scrollHeight, minPx) + 'px'; }
     function renderBmcCards(){
       const wrap = document.getElementById('bmcGrid'); if(!wrap) return;
       wrap.innerHTML = '';
       const bmc = CURRENT_PROJECT?.bmc || {};
       BMC_LABELS.forEach(([k, label])=>{
         const card = document.createElement('div'); card.className = 'bmc-card';
         const title = document.createElement('div'); title.className = 'bmc-title'; title.textContent = label;
         const ro = document.createElement('div'); ro.className = 'bmc-ro';
         const val = (bmc?.[k] || '').trim();
         ro.innerHTML = val ? textToHTML(val) : '<span class="bmc-empty">—</span>';
         card.appendChild(title); card.appendChild(ro); wrap.appendChild(card);
       });
     }
     function renderUserMemos(focusLast=false){
       const listEl = document.getElementById('userMemoList'); if(!listEl) return;
       listEl.innerHTML = '';
       const memos = loadUserMemos();
-      memos.forEach((m, idx)=>{
-        const card = document.createElement('div'); card.className = 'memo-card';
-        const del = document.createElement('button'); del.className='memo-del'; del.textContent='삭제';
-        del.addEventListener('click', ()=>{ const cur = loadUserMemos(); cur.splice(idx,1); saveUserMemos(cur); renderUserMemos(); });
-        const ta = document.createElement('textarea'); ta.className='memo-input'; ta.value = m.text || '';
-        ta.addEventListener('input', ()=>{ const cur = loadUserMemos(); cur[idx] = { ...cur[idx], text: ta.value, updatedAt: Date.now() }; saveUserMemos(cur); autoGrow(ta); });
-        requestAnimationFrame(()=> autoGrow(ta));
-        card.appendChild(del); card.appendChild(ta); listEl.appendChild(card);
-        if (focusLast && idx===memos.length-1){ setTimeout(()=>{ ta.focus(); ta.setSelectionRange(ta.value.length, ta.value.length); }, 0); }
-      });
-    }
-    function addUserMemo(){ const memos = loadUserMemos(); memos.push({ id: Date.now(), text:'', updatedAt: Date.now() }); saveUserMemos(memos); renderUserMemos(true); }
+      memos.forEach((m, idx)=>{
+        const card = document.createElement('div'); card.className = 'memo-card';
+        const del = document.createElement('button'); del.className='memo-del'; del.textContent='삭제';
+        del.addEventListener('click', ()=>{ const id = m.memo_id || m.id; store.removeMemo(id); renderUserMemos(); });
+        const ta = document.createElement('textarea'); ta.className='memo-input'; ta.value = m.text || '';
+        ta.addEventListener('input', ()=>{ const id = m.memo_id || m.id; store.updateMemo(id, { text: ta.value }); autoGrow(ta); });
+        requestAnimationFrame(()=> autoGrow(ta));
+        card.appendChild(del); card.appendChild(ta); listEl.appendChild(card);
+        if (focusLast && idx===memos.length-1){ setTimeout(()=>{ ta.focus(); ta.setSelectionRange(ta.value.length, ta.value.length); }, 0); }
+      });
+    }
+    function addUserMemo(){ if (!CURRENT_PID) return; store.addMemo(CURRENT_PID, ''); renderUserMemos(true); }
 
     function initChat(){
       const CHAT_KEY = 'fw_editor_chat_log';
       const CHAT_MAX = 1000;
       const CHAT_RENDER_WINDOW = 120;
       const TRIM_AT_LOAD = 2000;
 
       const log = document.getElementById('chatLog');
       const input = document.getElementById('chatInput');
       const send = document.getElementById('chatSend');
       const btnOlder = document.getElementById('chatLoadOlder');
       const btnExport = document.getElementById('chatExport');
       const btnClear = document.getElementById('chatClear');
       const stats = document.getElementById('chatStats');
 
       let all = [], startIdx = 0;
 
       function loadChat(){
         let arr = []; try{ arr = JSON.parse(localStorage.getItem(CHAT_KEY) || '[]'); }catch(e){ arr = []; }
         if (arr.length > TRIM_AT_LOAD){ arr = arr.slice(-CHAT_MAX); localStorage.setItem(CHAT_KEY, JSON.stringify(arr)); }
         return arr;
       }
       function saveChat(list){ if (list.length > CHAT_MAX) list = list.slice(-CHAT_MAX); localStorage.setItem(CHAT_KEY, JSON.stringify(list)); return list; }
       function bubbleEl(m){ const d = document.createElement('div'); d.className = 'bubble ' + (m.role==='me' ? 'me' : 'bot'); d.textContent = m.text; return d; }
       function updateStats(){ const end = Math.min(all.length, startIdx + CHAT_RENDER_WINDOW); stats.textContent = `${all.length ? (startIdx+1) : 0} - ${end} / ${all.length}`; }
@@ -1064,118 +1100,118 @@ FILE: editor.html
         const mid = (low + high) >> 1;
         el.textContent = original.slice(0, mid);
         if (page.scrollHeight <= page.clientHeight){ fit = mid; low = mid + 1; }
         else { high = mid - 1; }
       }
       const rest = original.slice(fit);
       if (rest.length){
         const clone = el.cloneNode(false);
         clone.textContent = rest;
         next.insertBefore(clone, next.firstChild);
       }
     }
 
     /* ===== Toast ===== */
     function initToast(){
       const div = document.createElement('div');
       div.style.position='fixed'; div.style.left='50%'; div.style.bottom='24px'; div.style.transform='translateX(-50%)';
       div.style.padding='10px 14px'; div.style.border='1px solid #E5E7EB'; div.style.background='#fff'; div.style.borderRadius='10px';
       div.style.boxShadow='0 8px 24px rgba(0,0,0,.08)'; div.style.fontSize='13px'; div.style.color='#111827';
       div.style.display='none'; div.style.zIndex='9999';
       document.body.appendChild(div);
       window.toast = (msg)=>{ div.textContent = msg; div.style.display='block'; setTimeout(()=> div.style.display='none', 1200); };
     }
 
     /* ===== Init ===== */
-    function initNotePanelAndEditor(){
-      const lastNodeGlobal = localStorage.getItem(LAST_NODE_GLOBAL);
-      let initialProject = null;
-
-      if (lastNodeGlobal){
-        const [pid] = splitFullPath(lastNodeGlobal);
-        const p = getProjectById(pid);
-        if (p){ initialProject = p; }
-      }
-      if (!initialProject){
-        const list = getProjectList();
-        const lastPid = localStorage.getItem(LAST_ID_KEY);
-        initialProject = (lastPid && getProjectById(lastPid)) || (list && list[0]) || getDraft() || null;
-      }
+    function initNotePanelAndEditor(){
+      const storedLastNode = store.getLastNodePath() || localStorage.getItem(LAST_NODE_GLOBAL);
+      let initialProject = null;
+
+      if (storedLastNode){
+        const [pid] = splitFullPath(storedLastNode);
+        const p = getProjectById(pid);
+        if (p){ initialProject = p; }
+      }
+      if (!initialProject){
+        const list = getProjectList();
+        const lastPid = store.getLastProjectId() || localStorage.getItem(LAST_ID_KEY);
+        initialProject = (lastPid && getProjectById(lastPid)) || (list && list[0]) || null;
+      }
 
       if (!initialProject){
         const root = document.getElementById('tocRoot');
         if (root) root.innerHTML = '<div class="text-[13px] text-gray-500">복원할 프로젝트가 없습니다. Projects에서 새로 생성해 주세요.</div>';
         return;
       }
 
-      CURRENT_PROJECT = initialProject;
-      CURRENT_PID = initialProject.id;
-      localStorage.setItem(LAST_ID_KEY, CURRENT_PID);
-
-      rerenderToc();
+      CURRENT_PROJECT = initialProject;
+      CURRENT_PID = initialProject.id;
+      CURRENT_NOTE = null;
+      localStorage.setItem(LAST_ID_KEY, CURRENT_PID);
+
+      rerenderToc();
 
       editor.pageRoot = document.getElementById('pageRoot');
       editor.title    = document.getElementById('docTitle');
       editor.saveBtn  = document.getElementById('manualSave');
       editor.tagRow   = document.getElementById('tagRow');
       editor.addTagBtn = document.getElementById('addTagBtn');
 
       // 최초 페이지
       ensureAtLeastOnePage();
       updatePageDividers();
 
       // 입력/저장
-      editor.pageRoot.addEventListener('input', ()=>{ if (PAGE.enabled) reflowPagesDeferred(); autosave(); });
-      editor.title.addEventListener('input', autosave);
-      editor.saveBtn?.addEventListener('click', saveCurrentDoc);
-
-      // 태그 추가
-      editor.addTagBtn?.addEventListener('click', ()=>{
-        if (!CURRENT_NODE_PATH){ toastOnce('먼저 좌측 목차에서 문서를 선택하세요'); return; }
-        const [, sub] = splitFullPath(CURRENT_NODE_PATH);
-        const t = prompt('태그 입력'); if(!t) return;
-        const arr = safeParse(localStorage.getItem(tagKeyFor(CURRENT_PID, sub)), []);
-        arr.push(t); localStorage.setItem(tagKeyFor(CURRENT_PID, sub), JSON.stringify(arr));
-        renderTagsFor(CURRENT_PID, sub);
-      });
+      editor.pageRoot.addEventListener('input', ()=>{ if (PAGE.enabled) reflowPagesDeferred(); autosave(); });
+      editor.title.addEventListener('input', autosave);
+      editor.saveBtn?.addEventListener('click', ()=> saveCurrentDoc({ manual:true, createVersion:true, versionType:'manual', versionLabel:'수동 저장' }));
+
+      // 태그 추가
+      editor.addTagBtn?.addEventListener('click', ()=>{
+        if (!CURRENT_NODE_PATH){ toastOnce('먼저 좌측 목차에서 문서를 선택하세요'); return; }
+        const [, sub] = splitFullPath(CURRENT_NODE_PATH);
+        const t = prompt('태그 입력'); if(!t) return;
+        store.addTag(CURRENT_PID, sub, t);
+        renderTagsFor(CURRENT_PID, sub);
+      });
 
       // 시작 문서: 폴더(id::psst)는 회피하고 기본은 P
-      const fallbackSub = 'psst/p';
-      let startPath = lastNodeGlobal || `${CURRENT_PID}::${fallbackSub}`;
-      if (startPath.endsWith('::psst')) startPath = `${CURRENT_PID}::${fallbackSub}`;
-      openNodeDocument(startPath, lastNodeGlobal ? null : 'P');
-
-      renderBmcCards();
-      renderUserMemos();
-    }
+      const fallbackSub = 'psst/p';
+      let startPath = storedLastNode || `${CURRENT_PID}::${fallbackSub}`;
+      if (startPath.endsWith('::psst')) startPath = `${CURRENT_PID}::${fallbackSub}`;
+      openNodeDocument(startPath, storedLastNode ? null : 'P');
+
+      renderBmcCards();
+      renderUserMemos();
+    }
 
     function initSidebarAndPanels(){
       initSidebar();
       initToast();
       initTabs();
       initChat();
     }
 
     function initDragPasteAndToolbar(){
       initToolbar();
       initRichPaste();
       initDragAndDrop();
     }
 
     // 좌측 하단 버튼
     document.getElementById('linkBtn')?.addEventListener('click', ()=>{
       if (!CURRENT_NODE_PATH) { toastOnce('먼저 좌측 목차에서 문서를 선택하세요'); return; }
       const [pid, sub] = splitFullPath(CURRENT_NODE_PATH);
       const linked = { at: Date.now(), projectId: pid, node: sub, title: document.getElementById('docTitle').value || sub };
       localStorage.setItem('fw_linked_note', JSON.stringify(linked));
       toastOnce('노트를 연결했습니다.');
     });
-    document.getElementById('memoAddBtn')?.addEventListener('click', ()=>{ const memos = loadUserMemos(); memos.push({ id: Date.now(), text:'', updatedAt: Date.now() }); saveUserMemos(memos); renderUserMemos(true); });
+    document.getElementById('memoAddBtn')?.addEventListener('click', addUserMemo);
 
     window.addEventListener('load', ()=>{
       initSidebarAndPanels();
       initNotePanelAndEditor();
       initDragPasteAndToolbar();
     });
   </script>
 </body>
 </html>
